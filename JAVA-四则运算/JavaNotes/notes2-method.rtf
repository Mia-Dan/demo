{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fnil\fcharset0 Monaco;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red255\green255\blue10;\red0\green0\blue0;
}
{\*\expandedcolortbl;;\cssrgb\c20000\c20000\c20000;\cssrgb\c99942\c98555\c0;\cssrgb\c0\c0\c0;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \expnd0\expndtw0\kerning0
More generally, method declarations have six components, in order:\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	1	}\expnd0\expndtw0\kerning0
Modifiers\'97such as 
\f1 public
\f0 , 
\f1 private
\f0 , and others you will learn about later.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
The return type\'97the data type of the value returned by the method, or 
\f1 void
\f0  if the method does not return a value.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3	}\expnd0\expndtw0\kerning0
The method name\'97the rules for field names apply to method names as well, but the convention is a little different.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4	}\expnd0\expndtw0\kerning0
The parameter list in parenthesis\'97a comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, 
\f1 ()
\f0 . If there are no parameters, you must use empty parentheses.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	5	}\expnd0\expndtw0\kerning0
An exception list\'97to be discussed later.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	6	}\expnd0\expndtw0\kerning0
The method body, enclosed between braces\'97the method's code, including the declaration of local variables, goes here.
\b\fs34 \cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0

\b0\fs26 \cf0 A method returns to the code that invoked it when it\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
completes all the statements in the method,\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
reaches a 
\f1 return
\f0  statement, or\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
throws an exception (covered later),\
\pard\pardeftab720\partightenfactor0
\cf0 whichever occurs first.\
\
\pard\pardeftab720\partightenfactor0

\b\fs34 \cf2 \
Overloading Methods\
\
\pard\pardeftab720\partightenfactor0

\b0\fs26 \cf0 The Java programming language supports 
\i overloading
\i0  methods, and \cb3 Java can distinguish between methods with different 
\i method signatures
\i0 . This means that methods within a class can have the same name if they have different parameter lists\cb1  (there are some qualifications to this that will be discussed in the lesson titled "Interfaces and Inheritance").\
\
Overloaded methods are differentiated by the number and the type of the arguments passed into the method. In the code sample, 
\f1 draw(String s)
\f0  and 
\f1 draw(int i)
\f0  are distinct and unique methods because they require different argument types.\
You cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.\
\
\
\
\pard\pardeftab720\partightenfactor0

\b\fs34 \cf2 Arbitrary Number of Arguments
\b0\fs26 \cf0 \
\
You can use a construct called 
\i varargs
\i0  to pass an arbitrary number of values to a method. You use varargs when you don't know how many of a particular type of argument will be passed to the method. It's a shortcut to creating an array manually (the previous method could have used varargs rather than an array).\
\
\
\
\pard\pardeftab720\partightenfactor0

\b \cf0 class method
\b0 \
\
\pard\pardeftab720\partightenfactor0
\cf0 The Java programming language supports static methods as well as static variables. Static methods, which have the 
\f1 static
\f0  modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as in\
\
\pard\pardeftab720\partightenfactor0

\f2 \cf0 ClassName.methodName(args)\
\pard\pardeftab720\partightenfactor0

\f0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf0 A common use for static methods is to access static fields. For example, we could add a static method to the 
\f1 Bicycle
\f0  class to access the 
\f1 numberOfBicycles
\f0  static field:\
\
\pard\pardeftab720\partightenfactor0

\f2 \cf0 public 
\f3\b static
\f2\b0  int getNumberOfBicycles() \{\
    return numberOfBicycles;\
\}\
\pard\pardeftab720\partightenfactor0

\f0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf0 Class methods 
\i\b cannot
\i0\b0  access instance variables or instance methods directly\'97they must use an object reference. Also, class methods cannot use the 
\f1 this
\f0  keyword as there is no instance for 
\f1 this
\f0  to refer to.}